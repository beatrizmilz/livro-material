## readr
O pacote `readr`do tidyverse é utilizado para importar arquivos de texto, como `.txt` ou `.csv`, para o R.




O `readr` transforma 7 tipos de arquivos de textos em `tibbles` usando as funções:

- `read_csv()`: arquivos separados por vírgula.
- `read_tsv()`: arquivos separados por tab.
- `read_delim()`: arquivos separados por um delimitador qualquer. O argumento `delim=` indica qual caracter separa cada coluna no arquivo de texto.
- `read_fwf()`: arquivos compactos que devem ter sua largura especificada. Existem várias funções para especificar a largura ou posição.
- `read_table()`: arquivos de texto tabular com suas colunas separadas por espaço.
- `read_log()`: arquivos log do Apache.


Como exemplo, utilizaremos uma base de filmes do IMDB, gravada em diversos formatos. Os arquivos podem ser encontrados [neste link](https://github.com/curso-r/site-v2/raw/master/content/material/importacao/data/imdb.rds). 



```{r eval=FALSE}
library(readr)

imdb_csv <- read_csv(file = "data/imdb.csv")

```



Repare que o argumento `file=` representa o caminho até o arquivo. Se o arquivo a ser lido não estiver no diretório de trabalho da sua sessão, você precisa especificar o caminho até o arquivo. 



> **Exercício relâmpago!** Descubra qual a diferença entre as funções "read_csv()" e "read_csv2()?".

Para a maioria das funções `read_`, existe uma respectiva função `write_`. Essas funções servem para salvar bases em um formato específico de arquivo. Além do nome do arquivo a ser criado, você também precisa passar o objeto que será gravado. Repare nos exemplos abaixo que você precisa especificar a extensão do arquivo corretamente.

```{r include=FALSE}
library(readr)
```

```{r eval=FALSE}
write_csv(x = mtcars, path = "data/mtcars.csv")
write_delim(x = mtcars, delim = " ", path = "data/mtcars.txt")
```


Com excessão do arquivo `.fwf`, a forma de importar e escrever arquivos são muito semelhantes. Para a função `read_fwf`, além da necessidade de especificar o caminho até o arquivo, também é necessário especificar a posição da coluna, `col_position =`. Para isso usamos funções como `fwf_empty()` ou `fwf_widths()`. Este formato não tem uma função `write_` específica no pacote, mas podemos salvar bases em `fwf` com a função `write.fwf()` do pacote `gdata`.
```{r eval=FALSE}
library(gdata)
write.fwf(mtcars[,1:4],'data/mtcars.fwf',colnames = F)

read_fwf('data/mtcars.fwf', col_positions = fwf_empty('data/mtcars.fwf',col_names = c('mpg','cyl','disp','hp')))
```
Aqui, pegamos as 4 primeiras colunas de mtcars e criamos um arquivo `.fwf`, depois o transformamos em tibble. A função `fwf_empty` especifica a posição das colunas com base nas colunas que estão vazias. Para entender melhor o que cada função `fwf_` faz, entre em `help(read_fwf)`.



Observe que quando chamamos a função `read_`, uma mensagem é impressa na tela. 
```{r}
imdb_tsv <- read_tsv('data/imdb.tsv')
```
Essa mensagem está definindo a classe de cada variável. Se as variáveis não foram especificadas de maneira correta, você pode copiar esta messagem e reescrevê-la da forma desejada. 

No exemplo, suponha que você gostaria que a variável ano fosse um inteiro. Podemos resolver isso da seguinte forma:
```{r}
imdb_tsv <- read_tsv('data/imdb.tsv',col_types =  
 cols(
  titulo = col_character(),
  #mudando de double para integer
  ano = col_integer(),
  diretor = col_character(),
  duracao = col_double(),
  cor = col_character(),
  generos = col_character(),
  pais = col_character(),
  classificacao = col_character(),
  orcamento = col_double(),
  receita = col_double(),
  nota_imdb = col_double(),
  likes_facebook = col_double(),
  ator_1 = col_character(),
  ator_2 = col_character(),
  ator_3 = col_character()
))
```
Para conhecer as especificações das colunas disponíveis clique [aqui](https://readr.tidyverse.org/articles/readr.html#available-column-specifications).

Também é possível salvar objetos, como data.frames em um tipo especial de arquivos, o `.rds`. A vantagem dessa extensão é guardar a estrutura dos dados salvos, como a classe das colunas de um data.frame. Além disso, é uma boa alternativa para lidar com grandes bancos de dados, já que arquivos `.rds` serão bem mais compactos do que arquivos Excel.

```{r}
imdb_rds <- read_rds(path = "data/imdb.rds")
write_rds(mtcars, path = "data/mtcars.rds")
```




