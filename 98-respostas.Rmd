# Respostas

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

Não há apenas uma maneira de resolver os exercícios. Você pode encontrar soluções diferentes das nossas, algumas vezes mais práticas e eficientes, outras vezes menos. Quando estiver fazendo suas análises, tente buscar o equilíbrio entre eficiência e pragmatismo. Economizar 1 hora com a execução do código pode não valer a pena se você demorou 2 horas a mais para programá-lo.

## R básico

### R como calculadora {-}

**1.** Qual a diferença entre o R e o RStudio?

*O R é uma linguagem de programação e um programa que instalamos no nosso computador para interpretar código em linguagem R. O RStudio é um ambiente de desenvolvimento para programação em R, isto é, é um programa que nos ajuda a trabalhar com a linguagem R.*

---

**2.** Podemos usar o RStudio sem o R? E o R sem o RStudio?

*Não podemos usar o RStudio sem o R, pois o programa R é que interpreta os nossos códigos e devolve os resultados. Por outro lado, podemos usar o R sem o RStudio (ou qualquer outro ambiente de desenvolvimento), mas a nossa vida de pessoa programadora se torna muito mais difícil.*

---

**3.** Precisamos compilar nossos códigos de R?

*Não. Um código em R é interpretado linha a linha, isto é, podemos ir rodando nosso código parcialmente, conforme vamos escrevendo.*

---

**4.** Calcule o número de ouro no R. Dica: o número de ouro é dado pela expressão $\frac{1 + \sqrt{5}}{2}$.

```{r}
(1 + 5^(1 / 2))/2
```

*Também poderia ser resolvido usando a função `sqrt()` para calcular a raiz quadrada.*

```{r}
(1 + sqrt(5))/2
```


---

**5.** Por que é preferível escrevermos sempre o nosso código no *script* e não no *Console*?

*Porque o código é a documentação da nossa análise. Se parte da análise for feita diretamente no Console, parte da documentação será perdida.*


### Objetos e funções {-}

**1.** Qual a diferença entre os códigos abaixo?

```{r, eval = FALSE}
# Código 1
33 / 11

# Código 2
divisao <- 33 / 11
```

*O primeiro código calcula a divisão de 33 por 11 e devolve o resultado na tela. O segundo código faz o mesmo cálculo, mas guardo o resultado no objeto `divisao`, isto é, o resultado não é retornado na tela.*

---

**2.** Multiplique a sua idade por meses e salve o resultado em um objeto chamado `idade_em_meses`. Em seguida, multiplique esse objeto por 30 e salve o resultado em um objeto chamado `idade_em_dias`.

```{r}
idade_em_meses <- 31 * 12

idade_em_dias <- idade_em_meses * 30
```


---

**3.** Por que o nome `meu-objeto` não pode ser utilizado para criar um objeto? O que significa a mensagem de erro resultante?

```{r, error=TRUE}
meu-objeto <- 1
```

*Porque o sinal `-` é utilizado pelo R como o operador de subtração. O código acima está sendo interpretado como a subtração dos objetos `meu` e `objeto`. Como nenhum dos objetos existe na sessão, é devolvido um erro dizendo que o objeto `meu` (o primeiro deles) não foi encontrado.*

*No entanto, mesmo que os objetos existissem, seria retornado um erro. Neste caso, seria um erro de sintaxe, pois o R não sabe como interpretar a atribuição do valor ` 3` à operação `meu - objeto`. Veja que a mensagem de erro não é muito intuitiva, pois o R entende que `-<-` é uma função que esquecemos de definir.*

```{r, error=TRUE}
meu <- 1
objeto <- 2
meu-objeto <- 1
```

### Classes {-}

**1.** Guarde em um objeto chamado `nome` uma *string* contendo o seu nome completo.

```{r}
nome <- "William Nilson de Amorim"
```

---

**2.** Guarde em um objeto chamado `cidade` o nome da cidade onde você mora. Em seguida, guarde em um objeto chamado `estado` o nome do estado onde você mora. Usando esses objetos, resolva os itens abaixo:

**a.** Utilize a função `nchar()` para contar o número de caracteres em cada cada string.

```{r}
cidade <- "São Paulo"
estado <- "SP"

nchar(cidade)

nchar(estado)
```


**b.** Interprete o resultado do seguinte código:

```{r}
paste(cidade, estado)
```

*A função `paste` juntou (colou) as duas strings, uma do lado da outra, separando-as por um espaço. O resultado gerado foi uma única string.*

**c.** Interprete o resultado do seguinte código:

```{r}
paste(cidade, estado, sep = " - ")
```

*O argumento `sep` da função `paste()` nos permite escolher qual caracter será utilizado para separar as duas strings. Por padrão será utilizado um espaço em branco `" "`. No exemplo, foi utilizado um espaço, seguido de um traço, seguido de outro espaço. Sem os espaços o resultado seria:*

```{r}
paste(cidade, estado, sep = "-")
```

*Veja que qualquer caracter ou string pode ser utilizada como separador:*

```{r}
paste(cidade, estado, sep = " #tricolor ")
```

**d.** Desafio. Como você reproduziria o mesmo resultado do item (c) sem utilizar o argumento `sep`?

```{r}
paste(cidade, "-", estado)
```

**e.** Qual a diferença entre as funções `paste()` e `paste0()`?

*A função `paste0()` é equivalente à função `paste()` com o argumento `sep = ""`.* 

```{r}
paste(cidade, "-", estado)
paste(cidade, "-", estado, sep = "")
paste0(cidade, "-", estado)
```


### Vetores {-}

**1.** Guarde em um objeto a sequência de números de 0 a 5 e resolva os itens abaixos.

**a.** Use subsetting para fazer o R devolver o primeiro número dessa sequência. Em seguida, faça o R devolver o último número da sequência.

```{r}
vetor <- 0:5

# Primeiro elemento
vetor[1]

# Último elemento
vetor[6]
```

**b.** Multiplique todos os valores do vetor por -1. Guarde o resultado em
um novo objeto chamado `vetor_negativo`.

```{r}
vetor_negativo <- vetor * -1
vetor_negativo
```

---

**2.** Crie um vetor com o nome de tres frutas, guarde em um objeto chamado `frutas` e resolva os itens abaixo.

**a.** Utilize a a função `length()` para verificar o tamanho do vetor.

```{r}
frutas <- c("banana", "maçã", "mamão")

length(frutas)
```


**b.** Inspecione a saída de `paste("eu gosto de", frutas)` e responda se o tamanho do vetor mudou.

```{r}
paste("eu gosto de", frutas)
```

*O tamanho do vetor não muda. O que aconteceu foi o acréscimo do prefixo "eu gosto de" a cada valor do vetor `frutas`. Podemos confirmar essa afirmação calculando o comprimento do novo vetor:*

```{r}
length(paste("eu gosto de", frutas))
```

---

**3.** O que é reciclagem? Escreva um código em R que exemplifique esse comportamento.

*Reciclagem é a repetição de valores de um vetor para que uma operação com vetores de tamanhos diferentes possa ser realizada. Embora pareça um comportamento estranho, utilizamos a reciclagem o tempo todo dentro do R, muitas vezes sem perceber. No exemplo a seguir, os valores do `vetor_menor` serão repetidos (reciclados) até o dois vetores terem o mesmo tamanho. Então, o primeiro valor do vetor menor será somado com o promeiro valor do vetor maior, o segundo do menor somado com o segundo do maior e assim por diante.*

```{r}
# Exemplo
vetor_menor <- c(1, 3)
vetor_maior <- c(1, 2, 3, 4)

vetor_menor + vetor_maior
```

---

**4.** O que é coerção? Escreva um código em R que exemplifique esse comportamento.

*Coerção é a homogenização da classe dos valores de um vetor. Se construirmos um vetor com valores de classes diferentes, todos os valores serão reprimidos para a classe mais dominante entre eles. No exemplo abaixo, todos os valores do vetor foram transformados em `character`, pois `character` é mais dominante do que as demais classes presentes (`numeric` e `logical`).*

*Considerando apenas as principais classes, temos a seguinte ordem de dominância: `character > numeric > integer > logical`*.

```{r}
c(1, -3, "a", TRUE)
```

---

**5.** Por que a coerção pode ser um problema na hora de importarmos bases de dados para o R?

*Porque as colunas podem acabar sendo importadas com uma classe diferente daquela que estamos esperando e nenhum erro ou warning será devolvido. Por exemplo, se uma coluna da base que deveria ser numérica tiver, por algum descuido, qualquer tipo de caracter não numérico (texto), toda a coluna será importada como texto.*

*O caso mais comum desse problema é gerado pelo separador de decimais. Se não especificarmos corretamente qual é o separador de decimais que estamos utilizando na nossa base de dados na hora da importação, qualquer coluna com valores decimais será importada como texto.*

---

**6.** Use a função `sum()` para somar os valores de 1 a 100.

```{r}
sum(1:100)
```

---

**7.** Considere o vetor booleano a seguir:

```{r}
dolar_subiu <- c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE)
```

Este vetor tem informação de uma semana (7 dias, começando no domingo) indicando se o dólar subiu (TRUE) ou não subiu (FALSE) no respectivo dia. Interprete o resultado dos códigos abaixo:

**a.** `length(dolar_subiu)`

```{r}
length(dolar_subiu)
```

*Devolve o comprimento do vetor `dolar_subiu`. Podemos interpretar como o número de dias analisados nesse estudo.*

**b.** `dolar_subiu[2]`

```{r}
dolar_subiu[2]
```

*Verifica se o dólar subiu no segundo dia do estudo (segunda-feira).*

**c.** `sum(dolar_subiu)`

```{r}
sum(dolar_subiu)
```
*Verifica o número de dias que o dólar subiu (já que na soma, os valores `TRUE` viram 1 e os valores `FALSE` viram 0), no caso, 4 dias com alta do dólar.*

**d.** `mean(dolar_subiu)`

```{r}
mean(dolar_subiu)
```
*Verifica a proporção de dias em que o dólar subiu (a média de valores 0 e 1 é igual a proporção de valores 1), no caso, cerca de 57% dos dias.*

### Testes lógicos {-}

**1.** O código abaixo vai guardar no objeto `segredo` um número inteiro entre 0 e 10. Sem olhar qual número foi guardado no objeto, resolva os itens a seguir:

```{r}
segredo <- round(runif(1, min = 0, max = 10))
```

**a.** Teste se o segredo é maior ou igual a 0.

```{r}
segredo >= 0
```


**b.** Teste se o segredo é menor ou igual a 10.

```{r}
segredo <= 10
```


**c.** Teste se o segredo é maior que 5.

```{r}
segredo > 5
```


**d.** Teste se o segredo é par.

*Precisamos verificar se o resto da divisão por 2 é igual a zero.*

```{r}
# Resto da divisão por 2
segredo %% 2

# Guardando o resultado
resto <- segredo %% 2

# Teste
resto == 0

# Equivalentemente poderíamos fazer
segredo %% 2 == 0
```


**e.** Teste se `segredo * 5` é maior que a sua idade.

```{r}
segredo * 5 > 31
```

**f.** Desafio. Escreva um teste para descobrir o valor do segredo.

*Vamos descobrir a posição do segredo no vetor `0:10`.*

```{r}
numeros_possiveis <- 0:10
numeros_possiveis

segredo == numeros_possiveis
```

*No código acima, para cada valor de `numero_possiveis`, foi testado se esse valor é igual ao segredo. Em caso afirmativo, um TRUE é devolvido. Veja que há apenas um TRUE no vetor resultante. Essa é posição do nosso segredo dentro do vetor `numeros_possiveis`.*

*Podemos usar esse vetor de TRUE/FALSE para recuperar o valor do segredo fazendo subsetting.*

```{r}
# Eis o valor do segredo
numeros_possiveis[segredo == numeros_possiveis]
```

*No código acima, foi retornado apenas o número associado ao valor TRUE dado pelo teste `segredo == numeros_possiveis`*.

---

**2.** Escreva um código em R que devolva apenas os valores maiores
ou iguais a 10 do vetor abaixo:

```{r}
vetor <- c(4, 8, 15, 16, 23, 42)

# Resposta
vetor[vetor >= 10]
```

---

**3.** Use o vetor numeross abaixo para responder as questoes seguintes.

```{r}
numeros <- -4:2
```

**a.** Escreva um código que devolva apenas valores positivos do vetor `numeros`.

```{r}
numeros[numeros > 0]
```


**b.** Escreva um código que devolta apenas os valores pares do vetor `numeros`.

```{r}
# Resto da divisão por 2
numeros %% 2

# Quais números são pares?
numeros %% 2 == 0

# Usando para filtrar o vetor
numeros[numeros %% 2 == 0]
```

**c.** Filtre o vetor para que retorne apenas aqueles valores que, quando elevados a 2, são menores do que 4.

```{r}
# Quadrado dos valores do vetor
numeros^2

# Aqueles menores que 4
numeros^2 < 4

# Usando para filtrar
numeros[numeros^2 < 4]
```

### Valores especiais {-}

**1.** Quais as diferenças entre `NaN`, `NULL`, `NA` e `Inf`? Digite expressões que retornem cada um desses valores.

- *O `NaN` representa uma indefinição matemática. Todo `NaN` é um `NA`, mas o contrário não é verdade.*

```{r}
0/0
```


- *O `NA` representa o nosso desconhecimento acerca de um valor. Esse valor existe, mas nós não o conhecemos. Na Estatística, ele é conhecido como valor omisso ou valor faltante.*

```{r}
sum(c(1, NA))
```

- *O `NULL` é um valor especial para o R, isto é, ao contrário do NA, ele não tem um significado prático para a análise de dados, mas sim computacional. Ele representa a ausência de um vetor e é útil na construção da lógica de programação de alguns códigos.*

```{r}
mtcars$coluna_que_nao_existe
```

- *O `Inf` representa um número muito grande (que o computador não consegue representar) ou um limite matemático.*

```{r}
2^2000
```

---

**2.** Escreva um código que conte o número de `NAs` do vetor `b`.

```{r}
b <- c(1, 0, NA, NA, NA, NA, 7, NA, NA, NA, NA, NA, 2, NA, NA, 10, 1, 1, NA)
```

```{r}
sum(is.na(b))
```



### Data frames {-}

**1.** Quais códigos abaixo retornam **um vetor** com a coluna `mpg` do data frame `mtcars`?

**a.** `mtcars$mpg`

```{r}
mtcars$mpg
```

*Retorna!*


**b.** `mtcars[ , 3]`

```{r}
mtcars[ , 3]
```

*Não retorna. A coluna `mpg` é a primeira coluna do data frame. A coluna que esse código retornou foi a `disp`.* 

**c.** `mtcars("mpg")`

```{r, error = TRUE}
mtcars("mpg")
```
*A sintaxe desse código não é válida pois `()` não são utilizados para fazer subsetting, mas sim para definir os argumentos de uma função (e `mtcars` não é uma função).*

**d.** `mtcars[ , "mpg"]`

```{r}
mtcars[ , "mpg"]
```

"Retorna!"

**e.** `mtcars.mpg`

```{r, error=TRUE}
mtcars.mpg
```

*Essa sintaxe não é válida no R. Ele está procurando por um objeto chamado `mtcars.mpg`, que não existe.*

**f.** `mtcars[ , 1]`

```{r}
mtcars[ , 1]
```

*Retorna!*

**g.** `mtcars[1, 1]`

```{r}
mtcars[1, 1]
```

*Esse código retorna apenas o primeiro valor da coluna `mpg`.*

h. `mpg$mtcars`

```{r, error = TRUE}
mpg$mtcars
```

*Não retorna. Essa sintaxe não é válida para selecionar colunas de um data frame. O correto seria `nome_do_data_frame$nome_da_coluna`.*

---

**2.** Para que serve a função `str()`. Dê um exemplo do seu uso.

*Serve para espiarmos a estrutura de um data frame, como número de linhas, colunas, classes das colunas e exemplo de valores em cada uma delas.*

```{r}
str(mtcars)
```


**3.** Para que serve a função `nanes()`. Dê um exemplo do seu uso.

*Serve para observamos os nomes das colunas de um data frame. O valor retornado é um vetor de strings.*

```{r}
names(mtcars)
```


**4.** Use o data frame `airquality` para responder às questões abaixo:

**a.** Quantas colunas `airquality` tem?

```{r}
ncol(airquality)
```


**b.** Quantas linhas `airquality` tem?

```{r}
nrow(airquality)
```

**c.** O que a função `head()` retorna?

*Retorna as 6 primeiras linhas do data frame.*

```{r}
head(airquality)
```


**d.** Quais são os nomes das colunas?

```{r}
names(airquality)
```

**e.** Qual é a classe da coluna `Ozone`?

```{r}
str(airquality)

# Também podemos ver apenas a coluna Ozone
class(airquality$Ozone)
```


**5.** Desafio. Calculando desvio-padrão no R. Use o data frame `airquality` para responder às questões abaixo:

**a.** Tire a média da coluna Ozone e guarde em um objeto.

```{r}
media_ozone <- mean(airquality$Ozone, na.rm = TRUE)
```


**b.** Guarde em um objeto o vetor correspondente à coluna Ozone subtraída da sua própria média (calculada em no item a).

```{r}
ozone_centralizado <- airquality$Ozone - media_ozone
```


**c.** Eleve o vetor calculado em (b) ao quadrado. Salve o resultado em um novo objeto.

```{r}
ozone_centr_quadrado <- ozone_centralizado ^ 2
```


**d.** Tire a média do vetor calculado em (c) e salve o resultado em um objeto chamado `variancia`. Em seguida, calcule a raiz quadrada desse valor e salve em um objeto chamado `desvio_padrao`.

```{r}
variancia <- mean(ozone_centr_quadrado, na.rm = TRUE)
desvio_padrao <- sqrt(variancia)
```


**e.** Compare o valor de `desvio_padrao` com `sd(airquality$Ozone)` e pesquise por que os valores não são iguais. Dica: veja a documentação da função `sd()`.

```{r}
desvio_padrao
sd(airquality$Ozone, na.rm = TRUE)
```

*Os valores não são iguais, pois na nossa conta, ao calcularmos a média no item (d), dividimos a soma de quadrados por `n` (tamanho da amostra, no caso, 116), enquanto na função `sd()` a divisão é por `n - 1` (115). A divisão por `n - 1`, na Estatística, representa o estimador não viesado para a variância/desvio-padrão de uma quantidade. Na prática, ambas podem ser utilizadas como medidas de variabilidade, mas em contextos inferenciais o valor dividido por `n - 1` é preferível.*

*Para chegarmos no mesmo resultado, poderíamos fazer:*

```{r}
# Número de valores sem NA
n <- length(na.omit(airquality$Ozone))

variancia <- sum(ozone_centr_quadrado, na.rm = TRUE) / (n - 1)
desvio_padrao <- sqrt(variancia)
desvio_padrao
```

---

**6.** Use o *data frame* `airquality` para responder às questões abaixo.

**a.** Conte quantos `NAs` tem na coluna `Solar.R`.

```{r}
sum(is.na(airquality$Solar.R))
```

**b.** Filtre a tabela `airquality `com apenas linhas em que `Solar.R` é `NA`.

```{r}
tab <- airquality[is.na(airquality$Solar.R),]

# Imprimindo apenas as primeiras linhas para facilitar a leitura
head(tab)
```

**c.** Filtre a tabela `airquality` com apenas linhas em que `Solar.R` **não** é `NA`.

```{r}
tab <- airquality[!is.na(airquality$Solar.R),]

# Imprimindo apenas as primeiras linhas para facilitar a leitura
head(tab)
```


**d.** Filtre a tabela `airquality` com apenas linhas em que `Solar.R` **não** é `NA` e `Month` é igual a 5.

```{r}
tab <- airquality[!is.na(airquality$Solar.R) & airquality$Month > 5,]

# Imprimindo apenas as primeiras linhas para facilitar a leitura
head(tab)
```

### Mais sobre funções {-}

**1.** Qual dos códigos abaixo devolverá um erro se for avaliado?

**a.** `3 * 5 + 10`

```{r}
3 * 5 + 10
```

*Sem erro.*

**b.** `function <- 10`

```{r, error=TRUE}
function <- 10
```

*Retorna erro pois `function` é um nome reservado no R. Não podemos utilizá-lo para nomear outros objetos.*

**c.** `mean(1, 10)`

```{r}
mean(1, 10)
```
*Não retorna erro, mas o 10 não é considerado na média. O código correto seria `mean(c(1, 10))`.*

**d.** `(soma <- sum(1, 1))`

```{r}
(soma <- sum(1, 1))
```
*Não retorna erro. Cercar o código com parênteses força a saída a sempre ser apresentada no Console, além de ser gravada dentro do objeto.*

---

**2.** Crie uma função que receba um número e retorne o quadrado deste número.

```{r}
quadrado <- function(x) {
  x ^ 2
}

quadrado(2)
quadrado(3)
quadrado(0)
```


---

**3.** Crie uma função que receba 2 números e devolva a raiz quadrada da soma desses números.

```{r}
raiz_da_soma <- function(a, b) {
  sqrt(a + b)
}

raiz_da_soma(2, 2)
raiz_da_soma(1, 4)
```

---

**4.** Crie uma função que receba dois valores (numéricos) e devolva o maior deles.

```{r}
retornar_maior <- function(x, y) {
  vetor <- c(x, y)
  filtro <- c(x > y, x <= y)
  vetor[filtro]
}

retornar_maior(10, 20)
retornar_maior(5, -5)
```

*Também poderíamos resolver usando a função `max()`.

```{r}
retornar_maior <- function(x, y) {
  max(x, y)
}

retornar_maior(10, 20)
retornar_maior(5, -5)
```

---

**5.** Use a função `runif()` para criar uma função que retorne um número aleatório inteiro entre 0 e 10 (0 e 10 inclusive). Caso você não conheça a função `runif()`, rode `help(runif)` para ler a sua documentação.

```{r}
sortear_numero <- function() {
  numero <- runif(1, min = 0, max = 10)
  
  numero_inteiro <- round(numero)
  
  return(numero_inteiro)
}

sortear_numero()
```


---

**6.** Rode `help(sample)` para descobrir o que a função `sample()` faz. Em seguida: 

**a.** Use a função `sample()` para escrever uma função que devolva uma linha aleatória de um *data frame*.

```{r}
sortear_linha <- function(data_frame) {
  num_linhas <- nrow(data_frame)
  linha_sorteada <- sample(1:num_linhas, 1)
  
  data_frame[linha_sorteada, ]
}

sortear_linha(mtcars)
```

**b.** Generalize a função para retornar um número qualquer de linhas, escolhido pelo usuário.

```{r}
sortear_linha <- function(data_frame, n) {
  num_linhas <- nrow(data_frame)
  linha_sorteada <- sample(1:num_linhas, n)
  
  data_frame[linha_sorteada, ]
}

sortear_linha(mtcars, 10)
```

### Controle de fluxo {-}

**1.** Por que o código abaixo retorna erro? Arrume o código para retornar o valor `TRUE`.

```{r, eval = FALSE}
x <- 4
if(x = 4) {
  TRUE
}
```

**Porque a expressão dentro do `if` deve retornar um valor lógico (TRUE ou FALSE) e o código `x = 4` é uma atribuição (equivalente a `x <- 4`). O correto seria utilizar `==` em vez de `=`.*

```{r}
x <- 4
if(x == 4) {
  TRUE
}
```

---

**2.** Usando `if` e `else`, escreva um código que retorne a string `"número"` caso um valor `x` seja da classe `numeric` ou `integer`; a string `"palavra"` caso seja da classe `character`; e `NA` caso contrário.

```{r}
x <- 10

if (class(x) == "numeric" | class(x) == "integer") {
  "número"
} else if (class(x) == "character") {
  "palavra"
} else {
  NA
}
```
**Uma solução mais simples seria utilizar as funções `is.numeric()` e `is.character()`.**

```{r}
x <- "qualquer texto"

if (is.numeric(x)) {
  "número"
} else if (is.character(x)) {
  "palavra"
} else {
  NA
}
```

---

**3.** Usando apenas `for` e a função `length()`, construa uma função que calcule a média de um vetor numérico qualquer. Construa uma condição para a função retornar `NULL` caso o vetor não seja numérico.

```{r}
minha_media <- function(vetor) {

  soma <- 0
  
  for (i in 1:length(vetor)) {
    soma <- soma + vetor[i]
  }
  
  media <- soma / length(vetor)  
  
  return(media)
  
}

minha_media(c(1, 2))
minha_media(0:10)
minha_media(c(2, 2))
```

---

**4.** Utilize o vetor `a` para resolver as questões a seguir:

```{r}
a <- c(10, 3, 5, -1, 3, -4, 8, 9, -10)
```

**a.** Utilize o `for` para imprimir as médias acumuladas do vetor `a`, isto é, primeiro vamos imprimir 10, depois a média entre 10 e 3, depois a média entre 10, 3 e 5 e assim por diante.

```{r}
soma <- 0

for(i in 1:length(a)) {
  soma <- soma + a[i]
  
  print(soma / i)
}
```


**b.** Adapte o laço que você fez no item anterior para ignorar os valores negativos, isto é, em caso de valor negativo, o laço não deve calcular a média e não imprimir nada.

```{r}
soma <- 0
divisor <- 0

for(i in 1:length(a)) {
  if (a[i] >= 0) {
    soma <- soma + a[i]
    divisor <- divisor + 1
    print(soma / divisor)
  }
}
```


## Pipe

---

**1.** Reescreva a expressão abaixo utilizando o `%>%`.

```{r, eval = FALSE}
round(mean(sum(1:10)/3), digits = 1)

1:10 %>%
  sum %>%
  divide_by(3) %>%
  round(digits = 1)
```

---

**2.** Reescreva o código abaixo utilizando o `%>%`.

```{r, eval = FALSE}
# Setamos a semente que gera números aleatórios para deixar o resultado reprodutível

set.seed(137)

x <- rnorm(100)
x.pos <- x[x>0]
media <- mean(x.pos)
saida <- round(media, 2)
saida
```


```{r, eval = FALSE}
set.seed(137)

rnorm(100) %>%
  magrittr::extract(. > 0) %>%
  mean %>%
  round(digits = 2)
```

---

**3.** Sem rodar, diga qual a saída do código abaixo. Consulte o help das funções caso precise.

```{r, eval = FALSE, collapse = TRUE}
2 %>%
  add(2) %>%
  c(6, NA) %>%
  mean(na.rm = T) %>%
  equals(5)
```

- *Primeiro, somamos 2 com 2, gerando o valor 4.*
- *Então colocamos esse valor em um vetor com os valores 6 e `NA`.*
- *Em seguida, tiramos a média desse vetor, desconsiderando o `NA`, obtendo o valor 5.*
- *Por fim, testemos se o valor é igual a 5, obtendo o valor `TRUE`.*


## Importação

### O pacote readr {-}

**1.** Qual a diferença entre as funções `read_csv()` e `read_csv2()`?

*A função `read_csv() lê arquivos CSV separados por vírgula (padrão norte-americano). A função `read_csv2()` lê arquivos CSV separados por ponto-e-vírgula (padrão brasileiro, já que usamos a vírgula como seperador de decimais).*

---

**2.** Leia o arquivo `imdb.csv` utilizando a função `read_delim()`.

```{r, eval = FALSE}
library(readr)

read_delim("imdb.csv", delim = ",")
```


---

**3.** Escreva a base mtcars em um arquivo `mtcars.csv` que não contenha o nome das colunas.

```{r, eval = FALSE}
write_csv(mtcars, "mtcars.csv", col_names = FALSE)
```


---

**4.** Use a função `write_rds()` para salvar em arquivos

**a)** Um número.

```{r, eval = FALSE}
numero <- 29
write_rds(numero, "numero.rds")
```

**b)** Um vetor de strings.

```{r, eval = FALSE}
estados <- c("SP", "RN", "AC", "MG")
write_rds(estados, "estados.rds")
```

**c)** Uma lista com valores númericos, textuais e lógicos.

```{r, eval = FALSE}
lista <- list(numero = 1, texto = c("M", "F", "F"), logico = FALSE)
write_rds(lista, "lista.rds")
```

**d)** As 3 primeiras colunas da base `mtcars`.

```{r, eval = FALSE}
write_rds(mtcars[,1:3], "mtcars_3_colunas.rds")
```

---

**5.** Utilize a função `read_rds()` para importar de volta para o R os arquivos criados no exercício 4.

```{r, eval=FALSE}
read_rds("numero.rds")
read_rds("estados.rds")
read_rds("lista.rds")
read_rds("mtcars_3_colunas.rds")
```


## O pacote dplyr

```{r, include=FALSE}
imdb <- readr::read_csv("assets/data/imdb.csv")
library(dplyr)
```


### Selecionando colunas

Utilize a base `imdb` nos exercícios a seguir.

**1.** Teste aplicar a função `glimpse()` do pacote `{dplyr}` à base `imdb`. O que ela faz?

```{r}
glimpse(imdb)
```

*A função `glimpse()` traz um resumo da base, contendo o número de linhas, colunas, o nome e tipo das colunas e as primeiras observações de cada coluna.*

---

**2.** Crie uma tabela com apenas as colunas `titulo`, `diretor`, e `orcamento.` Salve em um objeto chamado `imdb_simples`.

```{r}
imdb_simples <- select(imdb, titulo, diretor, orcamento)
imdb_simples
```

---

**3.** Selecione apenas as colunas `ator_1`, `ator_2` e `ator_3` usando o ajudante `contains()`.

```{r}
select(imdb, contains("ator"))
```

---

**4.** Usando a função `select()` (e seus ajudantes), escreva códigos que retornem a base IMDB sem as colunas `ator_1`, `ator_2` e `ator_3.` Escreva todas as soluções diferentes que você conseguir pensar. 

```{r, eval = FALSE}
select(imdb, -starts_with("ator"))

select(imdb, -ator_1, -ator_2, -ator_3)

select(imdb, -(ator_1:ator_3))

select(imdb, titulo:likes_facebook)

select(imdb, -contains("ator"))
```

### Ordenando a base

**1.** Ordene os filmes em ordem crescente de `ano` e decrescente de `receita` e salve em um objeto chamado `filmes_ordenados`.

```{r}
filmes_ordenados <- arrange(imdb, ano, desc(receita))
```

---

**2.** Selecione apenas as colunas `titulo` e `orcamento` e então ordene de forma decrescente pelo `orcamento`.

```{r, eval = FALSE}
# Aninhando as funções
arrange(select(imdb, titulo, orcamento), desc(orcamento))

# Criando objeto intermediário
imdb_aux <- select(imdb, titulo, orcamento)
arrange(imdb_aux, desc(orcamento))

# Pipe s2
imdb %>% 
  select(titulo, orcamento) %>% 
  arrange(desc(orcamento))
```

### Filtrando linhas

Utilize a base `imdb` nos exercícios a seguir.

**1.** Crie um objeto chamado `filmes_pb` apenas com filmes preto e branco.

```{r}
# Vendo categorias da variável cor
unique(imdb$cor)

# Filtrando
imdb %>% filter(cor == "Black and White")
```

---

**2.** Crie um objeto chamado `curtos_legais` com filmes de 90 minutos ou menos de duração e nota no imdb maior do que 8.5.

```{r}
curtos_legais <- imdb %>% 
  filter(duracao <= 90, nota_imdb > 8.5)
```

---

**3.** Retorne tabelas (`tibbles`) apenas com:

**a.** filmes coloridos anteriores a 1950;

```{r}
imdb %>% 
  filter(cor == "Color", ano < 1950)
```


**b.** filmes do "Woody Allen" ou do "Wes Anderson";

```{r}
imdb %>% 
  filter(diretor == "Woody Allen" | diretor == "Wes Anderson")
```


**c.** filmes do "Steven Spielberg" ordenados de forma decrescente por ano, mostrando apenas as colunas `titulo` e `ano`;

```{r}
imdb %>% 
  filter(diretor == "Steven Spielberg") %>% 
  arrange(desc(ano)) %>% 
  select(titulo, ano)
```


**d.**  filmes que tenham "Action" **ou** "Comedy" entre os seus gêneros;

```{r}
library(stringr)

# Solução 1
imdb %>% 
  filter(str_detect(generos, "Action") | str_detect(generos, "Comedy"))
```

**e.** filmes que tenham "Action" **e** "Comedy" entre os seus gêneros e tenha `nota_imdb` maior que 8;

```{r}
imdb %>% 
  filter(str_detect(generos, "Action"), str_detect(generos, "Comedy"))
```


**f.** filmes que não possuem informação tanto de receita quanto de orçamento (isto é, possuem `NA` em ambas as colunas).

```{r}
imdb %>% 
  filter(is.na(orcamento), is.na(receita))
```

### Modificando e criando novas colunas

**1.** Crie uma coluna chamada `prejuizo` (`orcamento - receita`) e salve a nova tabela em um objeto chamado `imdb_prejuizo`. Em seguida, filtre apenas os filmes que deram prejuízo e ordene a tabela por ordem crescente de prejuízo.

```{r}
imdb_prejuizo <- imdb %>% 
  mutate(prejuizo = orcamento - receita)

imdb_prejuizo %>% 
  filter(prejuizo > 0) %>% 
  arrange(prejuizo)
```

---

**2.** Fazendo apenas uma chamada da função mutate(), crie as seguintes colunas novas na base `imdb`:

**a.** `lucro = receita - orcamento`

**b.** `lucro_medio`

**c.** `lucro_relativo = (lucro - lucro_medio)/lucro_medio`

**d.** `houve_lucro = ifelse(lucro > 0, "sim", "não")`

```{r}
imdb %>% 
  mutate(
    lucro = receita - orcamento,
    lucro_medio = mean(lucro, na.rm = TRUE),
    lucro_relativo = (lucro - lucro_medio) / lucro_medio,
    houve_lucro = ifelse(lucro > 0, "sim", "não")
  )
```

---

**3.** Crie uma nova coluna que classifique o filme em `"recente"` (posterior a 2000) e `"antigo"` (de 2000 para trás).

```{r}
imdb %>% 
  mutate(antigo_ou_recente = ifelse(ano > 2000, "recente", "antigo"))
```

### Summarisando a base

Utilize a base `imdb` nos exercícios a seguir.

**1.** Calcule a duração média e mediana dos filmes
da base.

```{r}
imdb %>% 
  summarise(
    duracao_media = mean(duracao, na.rm = TRUE),
    duracao_mediana = median(duracao, na.rm = TRUE)
  )
```

---

**2.** Calcule o lucro médio dos filmes com duração
menor que 60 minutos.

```{r}
imdb %>% 
  filter(duracao < 60) %>% 
  mutate(lucro = receita - orcamento) %>% 
  summarise(lucro_medio = mean(lucro, na.rm = TRUE))
```

---

**3.** Apresente na mesma tabela o lucro médio dos filmes com duracao menor que 60 minutos e o lucro médio dos filmes com duracao maior ou igual a 60 minutos.

```{r}
imdb %>% 
  mutate(
    lucro = receita - orcamento,
    duracao_cat = ifelse(duracao < 60, "menor 60 min", "60 ou mais min")
  ) %>% 
  filter(!is.na(lucro)) %>% 
  group_by(duracao_cat) %>% 
  summarise(
    lucro_medio = mean(lucro, na.rm = TRUE)
  )
```

---

**4.** Retorne tabelas (`tibbles`) apenas com:

**a.** a nota IMDB média dos filmes por tipo de classificacao;

```{r}
imdb %>% 
  group_by(classificacao) %>% 
  summarise(nota_media = mean(nota_imdb, na.rm = TRUE))
```

**b.** a receita média e mediana dos filmes por ano;

```{r}
imdb %>% 
  group_by(ano) %>% 
  summarise(
    receita_media = mean(receita, na.rm = TRUE),
    receita_mediana = median(receita, na.rm = TRUE)
  )
```

**c.** apenas o nome dos diretores com mais de 10 filmes.

```{r}
imdb %>% 
  filter(!is.na(diretor)) %>% 
  group_by(diretor) %>% 
  summarise(num_filmes = n()) %>% 
  filter(num_filmes > 10) %>% 
  select(diretor)
```

*Também podemos usar a função `count()`.*

```{r}
imdb %>% 
  filter(!is.na(diretor)) %>% 
  count(diretor, name = "num_filmes") %>% 
  filter(num_filmes > 10) %>% 
  select(diretor)
```


### Juntando duas bases

**1.** Utilize a base `imdb` para resolver os itens a seguir.

**a.** Salve em um novo objeto uma tabela com a
nota média dos filmes de cada diretor. Essa tabela
deve conter duas colunas (`diretor` e `nota_imdb_media`)
e cada linha deve ser um diretor diferente.

```{r}
nota_diretores <- imdb %>% 
  group_by(diretor) %>% 
  summarise(nota_imdb_media = mean(nota_imdb))

nota_diretores
```


**b.** Use o `left_join()` para trazer a coluna
`nota_imdb_media` da tabela do item anterior
para a tabela `imdb` original.

```{r}
imdb %>% 
  left_join(nota_diretores, by = "diretor") %>% 
  select(nota_imdb_media, everything())
```

