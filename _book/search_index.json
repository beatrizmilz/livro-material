[
["r-básico.html", "Capítulo 3 R Básico 3.1 Pedindo Ajuda 3.2 R como calculadora 3.3 Objetos e Classes 3.4 Valores especiais 3.5 Controles de Fluxo 3.6 Fórmulas 3.7 Gráficos (base) 3.8 Exercícios 3.9 Respostas", " Capítulo 3 R Básico Introduziremos aqui os principais conceitos de progamação em R. Indicamos a leitura deste capítulo a quem nunca teve contato com uma linguagem de programação ou a quem gostaria de entender um pouco melhor a estrutura de objetos, funções e classes do R. 3.1 Pedindo Ajuda A linguagem R é bem intuitiva. É possível fazer bastante coisa à base da tentativa e erro. Além disso, grande parte do conhecimento é escalável, isto é, aprender a utilizar uma função é meio caminho andado para aprender todas as outras funções que operam de forma semelhante1. No entanto, a intuição não infalível, e recorrentemente vamos precisar de ajuda para rodar alguma função ou descobrir como fazer alguma tarefa no R. Felizmente, a comunidade R é bem ativa e existem vários lugares para buscar respostas. Nesta seção, vamos apresentar as principais maneiras algumas dessas maneiras. Figure 3.1: Arte por Allison Horst. Veja nas Referências onde encontrá-la. No R, há quatro principais entidades para se pedir ajuda: Help/documentação do R Google Stack Overflow Coleguinha A busca por ajuda é feita preferencialmente, mas não necessariamente, na ordem acima. 3.1.1 Documentação do R A documentação do R serve para você aprender a usar uma determinada função. ?mean help(mean) Cinco dicas: Os exemplos no final são particularmente úteis. Leia a seção Usage para ter noção de como usar a função. Os parâmetros da função estão descritos em Arguments. Caso essa função não atenda às suas necessidades, a seção See Also sugere funções relacionadas. Alguns pacotes possuem tutorias de uso mais completos. Esses textos são chamados de vignettes e podem ser acessados com a função vignette(package = 'nomeDoPacote'). Por exemplo, vignette(package = 'dplyr'). Bases de dados presentes em pacotes também têm documentação, e geralmente é possível encontrar o significado de cada variável nela. Por exemplo, help(mtcars). 3.1.2 Google Há uma comunidade gigantesca de usuários de R gerando diariamente uma infinidade de conteúdos e discussões. Não raramente, você irá encontrar discussões sobre o seu problema simplesmente jogando o seu erro no Google. Essa deve ser sua primeira tentativa para reseolver um problema! Pesquisas em inglês aumentam consideravelmente a chance de encontrar uma resposta. Exemplo (repare no ‘r’ adicionado na busca, isso ajuda bastante): log(&quot;5&quot;) ## Error in log(&quot;5&quot;): non-numeric argument to mathematical function 3.1.3 Stack Overflow O Stack Overflow e o Stack Overflow em Português são sites de Pergunta e Resposta amplamente utilizados por todas as linguagens de programação, e o R é uma delas. Nos EUA, chegam até a usar a reputação dos usuários como diferencial no currículo! Provavelmente o Google lhe indicará uma página deles quando você estiver procurando ajuda. E quando todas as fontes possíveis de ajuda falharem, o Stack Overflow lhe dará o espaço para criar sua própria pergunta. Um ponto importante: como fazer uma boa pergunta no Stack Overflow? No site, existe um tutorial com uma lista de boas práticas, que se encontra aqui. Resumindo, as principais dicas são ser conciso; ser específico; ter mente aberta; e ser gentil. Porém, no caso do R, há outro requisito que vai aumentar muito sua chance de ter uma boa resposta: exemplinho minimal e reprodutível. Ser minimal: usar bancos de dados menores e utilizar pedaços de códigos apenas suficientes para apresentar o seu problema. Não precisa de banco de dados de um milhão de linhas e nem colocar o seu código inteiro para descrever a sua dúvida. Ser reprodutível: o seu código deve rodar fora da sua máquina. Se você não fornecer uma versão do seu problema que rode (ou que imite seu erro), as pessoas vão logo desistir de te ajudar. Por isso, nunca coloque bancos de dados que só você tem acesso. Use bancos de dados que já vem no R ou disponibilize um exemplo (possivelmente anonimizado) em .csv na web para baixar. E se precisar utilizar funções diferentes, coloque as library’s correspondentes. 3.2 R como calculadora Pelo console, é possível executar qualquer comando do R. 1:30 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 Esse comando é uma forma simplificada de criar um vetor de inteiros de 1 a 30. Os números que aparecem entre colchetes ([1] e [24]) indicam o índice (ordem) do primeiro elemento impresso em cada linha. Quando compilamos? Quem vem de linguagens como o C ou Java espera que seja necessário compilar o código em texto para o código das máquinas (geralmente um código binário). No R, isso não é necessário. O R é uma linguagem de programação dinâmica que interpreta o seu código enquanto você o executa. Tente jogar no console: 2 * 2 - (4 + 4) / 2. Pronto! Com essa simples expressão você já é capaz de pedir ao R para fazer qualquer uma das quatro operações aritméticas básicas. A seguir, apresentamos uma lista resumindo como fazer as principais operações no R. # adição 1 + 1 ## [1] 2 # subtração 4 - 2 ## [1] 2 # multiplicação 2 * 3 ## [1] 6 # divisão 5 / 3 ## [1] 1.666667 # potência 4 ^ 2 ## [1] 16 # resto da divisão de 5 por 3 5 %% 3 ## [1] 2 # parte inteira da divisão de 5 por 3 5 %/% 3 ## [1] 1 Além do mais, as operações e suas precedências são mantidas como na matemática, ou seja, divisão e multiplicação são calculadas antes da adição e subtração. E os parênteses nunca são demais! Uma outra forma de executar uma expressão é escrever o código no script e teclar Ctrl + Enter. Assim, o comando é enviado para o console, onde é diretamente executado. Essa operação é chamada de avaliar o código ou, popularmente, de rodar o código. Se você digitar um comando incompleto, como 5 +, e apertar Enter, o R mostrará um +, o que não tem nada a ver com somar alguma coisa. Isso significa que o R está esperando que você complete o seu comando. Termine o seu comando ou aperte Esc para recomeçar. &gt; 5 - + + 5 [1] 0 Se você digitar um comando que o R não reconhece, ele retornará uma mensagem de erro. NÃO ENTRE EM PÂNICO! Ele só está avisando que não conseguiu interpretar o comando. Você pode digitar outro comando normalmente em seguida. &gt; 5 % 2 Error: unexpected input in &quot;5 % 2&quot; &gt; 5 ^ 2 [1] 25 3.3 Objetos e Classes O R te permite salvar valores dentro de um objeto. Para isso, utilizamos o operador &lt;-. No exemplo abaixo, salvamos o valor 1 em a. Sempre que avaliarmos o nome a, o R vai devolver o valor 1. # Salvando `1` em `a` a &lt;- 1 # Avaliando o objeto `a` a ## [1] 1 Atenção! O R diferencia letras maiúsculas e minúsculas, isto é, b é considerado um objeto diferente de B. Rode o exemplo abaixo e observe que depois objetos diferentes são criados no Environment. b &lt;- 2 B &lt;- 3 b ## [1] 2 B ## [1] 3 O objeto mais importante para o cientista de dados é, claro, a base de dados. No R, uma base de dados é representa por objetos chamados de data frames. A seguir, vamos entender o que são esses objetos. 3.3.1 Data frames (parte 1) Os data frames são de extrema importância no R, pois são os objetos que guardam os nossos dados. Eles são equivalentes a uma tabela do SQL ou uma planilha do Excel. A principal característica de um data frame é possuir linhas e colunas2. Veja o exemplo abaixo: mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 O mtcars é um data frame nativo do R que contém informações sobre diversos modelos de carros. Ele possui 32 linhas e 11 colunas3 Nos próximos capítulos, os data frames serão o nosso principal objeto de estudos. Aprenderemos a selecionar, criar e modificar colunas, filtrar e ordenar linhas, juntar dois data frames e, a partir deles, construiremos gráficos e ajustaremos modelos. Mas, antes disso, vamos estudar um pouco de estrutura de objetos dentro do R e assim entendermos o que de fato é um data frame. Um data frame no R é o mesmo que uma tabela do SQL ou uma planilha do Excel, por isso são objetos muito importantes. Usualmente, nossos dados serão importados para um objeto data.frame. Em grande parte do curso, eles serão o principal objeto de estudo. 3.3.2 Objetos atômicos A classe de um objeto é muito importante dentro do R. É a partir dela que as funções e operadores conseguem saber exatamente o que fazer com um objeto. Por exemplo, podemos somar dois números, mas não conseguimos somar duas letras (texto): 1 + 1 ## [1] 2 &quot;a&quot; + &quot;b&quot; ## Error in &quot;a&quot; + &quot;b&quot;: non-numeric argument to binary operator O operador + verifica que \"a\" e \"b\" não são números (ou que a classe deles não é numérica) e devolve uma mensagem de erro informando isso. Observe que para criar texto no R, colocamos os caracteres entre aspas. As aspas servem para diferenciar o nome de objetos dos textos (letras e palavras), comuns em variáveis categóricas. a &lt;- 10 # O objeto `a`, sem aspas a ## [1] 10 # A letra (texto) `a`, com aspas &quot;a&quot; ## [1] &quot;a&quot; As classes mais básicas dentro do R são: numeric character logical Veja alguns exemplos: # numeric 1 0.10 0.95 pi # characters &quot;a&quot; &quot;1&quot; &quot;positivo&quot; # logical TRUE FALSE Um objeto de qualquer uma dessas classes é chamado de objeto atômico. Esse nome se deve ao fato de que essas classes não se misturam, isto é, para um objeto ter a classe numeric todos os seus valores precisam ser numéricos. Mas como atribuir mais de um valor a um mesmo objeto? Para isso, precisamos criar vetores. 3.3.3 Vetores Vetores no R são os objetos mais simples que podem guardar objetos atômicos. vetor1 &lt;- c(1, 2, 3, 4) vetor2 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) vetor1 ## [1] 1 2 3 4 vetor2 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; De forma bastante intuitiva, você pode fazer operações com vetores. vetor1 - 1 ## [1] 0 1 2 3 Quando você faz vetor1 - 1, o R subtrai 1 de cada um dos elementos do vetor. O mesmo acontece quando você faz qualquer operação aritmética com vetores no R. vetor1 / 2 vetor1 * 10 Você também pode fazer operações que envolvem mais de um vetor: vetor1 * vetor1 ## [1] 1 4 9 16 Neste caso, o R irá alinhar os dois vetores e multiplicar elemento por elemento. Isso pode ficar um pouco confuso quando os dois vetores não possuem o mesmo tamanho: vetor2 &lt;- 1:3 vetor1 * vetor2 ## Warning in vetor1 * vetor2: longer object length is not a multiple of shorter ## object length ## [1] 1 4 9 4 O R alinhou os dois vetores e, como eles não possuíam o mesmo tamanho, foi repetindo o vetor menor até completar o vetor maior. Esse comportamento é chamado de reciclagem e é útil para fazer operações elemento por elemento (vetorizadamente), mas às vezes pode ser confuso. Com o tempo, você aprenderá a se aproveitar dele. 3.3.4 Classes Para saber a classe de um objeto, você pode usar a função class(). x &lt;- 1 class(x) ## [1] &quot;numeric&quot; y &lt;- &quot;a&quot; class(y) ## [1] &quot;character&quot; z &lt;- TRUE class(z) ## [1] &quot;logical&quot; Um vetor tem sempre a mesma classe dos objetos que guarda. class(vetor1) ## [1] &quot;numeric&quot; class(vetor2) ## [1] &quot;integer&quot; 3.3.5 Coerção 3.3.5.1 Misturando objetos Vetores são homogêneos. Os elementos de um vetor são sempre da mesma classe. Ou todos são numéricos, ou são todos character, ou todos são lógicos etc. Não dá para ter um número e um character no mesmo vetor, por exemplo. Se colocarmos duas ou mais classes diferentes dentro de um mesmo vetor, o R vai forçar que todos os elementos passem a pertencer à mesma classe. O número 1.7 viraria \"1.7\" se fosse colocado ao lado de um \"a\". y &lt;- c(1.7, &quot;a&quot;) # character y &lt;- c(TRUE, 2) # numeric y &lt;- c(TRUE, &quot;a&quot;) # character A ordem de precedência é: DOMINANTE — character &gt; complex &gt; numeric &gt; integer &gt; logical — RECESSIVO 3.3.5.2 Forçando classes explicitamente Você pode coagir um objeto a ser de uma classe específica com as funções as.character(), as.numeric(), as.integer() e as.logical(). É equivalente à função convert() do SQL. x &lt;- 0:4 class(x) ## [1] &quot;integer&quot; as.numeric(x) ## [1] 0 1 2 3 4 as.logical(x) ## [1] FALSE TRUE TRUE TRUE TRUE as.character(x) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; Se o R não entender como coagir uma classe na outra, ele soltará um warning informado que colocou NA no lugar. x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA Observação. O NA tem o mesmo papel que o null do SQL. Porém, há um NULL no R também, com diferenças sutis que vamos abordar mais adiante. 3.3.6 Matrizes Matrizes são vetores com duas dimensões (e por isso só possuem elementos de uma mesma classe). m &lt;- matrix(1:6, nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 dim(m) # funçăo dim() retorna a dimensăo do objeto. ## [1] 2 3 Repare que os números de 1 a 6 foram dispostos na matriz coluna por coluna (column-wise), ou seja, preenchendo de cima para baixo e depois da esquerda para a direita. Operações úteis m[3, ] # seleciona a terceira linha m[ , 2] # seleciona a segunda coluna m[1, 2] # seleciona o primeiro elemento da segunda coluna t(m) # matriz transposta m %*% n # multiplicação matricial solve(m) # matriz inversa de m 3.3.7 Fatores Fatores podem ser vistos como vetores de inteiros que possuem rótulos (levels). sexo &lt;- c(&quot;M&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;M&quot;, &quot;M&quot;, &quot;H&quot;) fator &lt;- as.factor(sexo) fator ## [1] M H H H M M H ## Levels: H M as.numeric(fator) ## [1] 2 1 1 1 2 2 1 Eles são úteis para representar uma variável categórica (nominal e ordinal). Na modelagem, eles serão tratados de maneira especial em funções como lm() e glm(). A função levels() retorna os rótulos do fator: levels(fator) ## [1] &quot;H&quot; &quot;M&quot; A ordem das categorias de um fator pode importar. Como exemplo, temos as caselas de referência de modelos estatísticos e a ordem das barras de um gráfico. Para ajudar nesta tarefa, consulte o pacote forcats. Um erro comum e desastroso. Quando um vetor de números está como factor, ao tentar transformá-lo em numeric, você receberá um vetor de inteiros que não tem nada a ver com os valores originais! numeros &lt;- factor(c(&quot;10&quot;, &quot;55&quot;, &quot;55&quot;, &quot;12&quot;, &quot;10&quot;, &quot;-5&quot;, &quot;-90&quot;)) as.numeric(numeros) ## [1] 3 5 5 4 3 1 2 #Por essa eu năo esperava! Para evitar isso, use as.character() antes de transformar para número. as.numeric(as.character(numeros)) ## [1] 10 55 55 12 10 -5 -90 # Agora está OK! 3.3.8 Listas Listas são um tipo especial de vetor que aceita elementos de classes diferentes. x &lt;- list(1:5, &quot;Z&quot;, TRUE, c(&quot;a&quot;, &quot;b&quot;)) x ## [[1]] ## [1] 1 2 3 4 5 ## ## [[2]] ## [1] &quot;Z&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] &quot;a&quot; &quot;b&quot; É um dos objetos mais importantes para armazenar dados e vale a pena saber manuseá-los bem. Existem muitas funções que fazem das listas objetos incrivelmente úteis. Criamos uma lista com a função list(), que aceita um número arbitrário de elementos. Listas aceitam QUALQUER tipo de objeto. Podemos ter listas dentro de listas, por exemplo. Como para quase todas as classes de objetos no R, as funções is.list() e as.list() também existem. Na lista pedido abaixo, temos numeric, Date, character, vetor de character e list contida em uma lista: pedido &lt;- list(pedido_id = 8001406, pedido_registro = as.Date(&quot;2017-05-25&quot;), nome = &quot;Athos&quot;, sobrenome = &quot;Petri Damiani&quot;, cpf = &quot;12345678900&quot;, email = &quot;athos.damiani@gmail.com&quot;, qualidades = c(&quot;incrível&quot;, &quot;impressionante&quot;), itens = list( list(descricao = &quot;Ferrari&quot;, frete = 0, valor = 500000), list(descricao = &quot;Dolly&quot;, frete = 1.5, valor = 3.90) ), endereco = list(entrega = list(logradouro = &quot;Rua da Glória&quot;, numero = &quot;123&quot;, complemento = &quot;apto 71&quot;), cobranca = list(logradouro = &quot;Rua Jose de Oliveira Coutinho&quot;, numero = &quot;151&quot;, complemento = &quot;5o andar&quot;) ) ) Operações úteis pedido$cpf # elemento chamado &#39;cpf&#39; pedido[1] # nova lista com apenas o primeiro elemento pedido[[2]] # segundo elemento pedido[&quot;nome&quot;] # nova lista com apenas o elemento chamado &#39;nome&#39; Certamente você se deparará com listas quando for fazer análise de dados com o R. Nos tópicos mais aplicados, iremos aprofundar sobre o tema. O pacote purrr contribui com funcionalidades incríveis para listas. 3.3.9 Data frames (parte 2) Os data.frame’s são listas especiais em que todos os elementos possuem o mesmo comprimento. Cada elemento dessa lista pode ser pensado como uma coluna da tabela. Seu comprimento representa o número de linhas. Já que são listas, essas colunas podem ser de classes diferentes. Essa é a grande diferença entre data.frame’s e matrizes. Algumas funções úteis para trabalhar com data.frame’s : head() - Mostra as primeiras 6 linhas. tail() - Mostra as últimas 6 linhas. dim() - Número de linhas e de colunas. names() - Os nomes das colunas (variáveis). str() - Estrutura do data.frame. Mostra, entre outras coisas, as classes de cada coluna. cbind() - Acopla duas tabelas lado a lado. rbind() - Empilha duas tabelas. O exemplo abaixo mostra que uma lista pode virar data.frame apenas se todos os elementos tiverem o mesmo comprimento. minha_lista &lt;- list(x = c(1, 2, 3), y = c(&quot;a&quot;, &quot;b&quot;)) as.data.frame(minha_lista) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 2 minha_lista &lt;- list(x = c(1, 2, 3), y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) as.data.frame(minha_lista) ## x y ## 1 1 a ## 2 2 b ## 3 3 c 3.4 Valores especiais Existem valores reservados para representar dados faltantes, infinitos, e indefinições matemáticas. NA (Not Available) significa dado faltante/indisponível. É o null do SQL ou o . do SAS. O NA tem uma classe, ou seja, podemos ter NA numeric, NA character etc. NaN (Not a Number) representa indefinições matemáticas, como 0/0 e log(-1). Um NaN é um NA, mas a recíproca não é verdadeira. Inf (Infinito) é um número muito grande ou o limite matemático, por exemplo, 1/0 e 10^310. Aceita sinal negativo -Inf. NULL representa a ausência de informação. Conceitualmente, a diferença entre NA e NULL é sutil, mas, no R, o NA está mais alinhado com os conceitos de estatística (ou como gostaríamos que os dados faltantes se comportassem em análise de dados) e o NULL está em sintonia com comportamentos de lógica de programação. Use as funções is.na(), is.nan(), is.infinite() e is.null() para testar se um objeto é um desses valores. x &lt;- c(NaN, Inf, 1, 2, 3, NA) is.na(x) ## [1] TRUE FALSE FALSE FALSE FALSE TRUE is.nan(x) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE 3.5 Controles de Fluxo Como toda boa linguagem de programação, o R possui estruturas de if’s, else’s, for’s, while’s etc. Esses controles de fluxo são importantes na hora de programar. 3.5.1 IF e ELSE O seguinte trecho de código só será executado se o objeto x for igual a 1. Repare que a condição de igualdade é representada por dois iguais ==. x &lt;- 2 if(x == 1) { Sys.time() # Devolve a data/hora no momento da execução. } x &lt;- 1 if(x == 1) { Sys.time() } ## [1] &quot;2020-04-20 20:41:26 -03&quot; O R só vai executar o que está na expressão dentro das chaves {} se o que estiver dentro dos parênteses () retornar TRUE. A sintaxe com o else e o if else é if(x &lt; 0) { sinal &lt;- &quot;negativo&quot; } else if(x == 0) { sinal &lt;- &quot;neutro&quot; } else if(x &gt; 0) { sinal &lt;- &quot;positivo&quot; } sinal ## [1] &quot;positivo&quot; Diferença entre SQL e R nas comparações lógicas Igualdade: no SQL é só um sinal de igual: &lt;2 = 1. No R são dois: 2 == 1. Diferença: teste de diferente no R é != em vez de de &lt;&gt;. Negação: em vez de usar a palavra “not” igual ao SQL, usamos !. Por exemplo, “entidade_id not in (‘100515’)” fica “!entidade_id %in% c(‘100515’)”. 3.5.2 for Vamos usar o for para somar todos os elementos de um vetor. x &lt;- 1:10 # Cria um vetor com a sequência 1, 2, ..., 10. soma &lt;- 0 for(i in 1:10) { soma &lt;- soma + x[i] } soma ## [1] 55 De forma equivalente, podemos usar diretamente a função sum(). sum(x) ## [1] 55 Agora, vamos imprimir na tela o resultado da divisão de cada elemento de um vetor por dois. Para isso, utilizaremos a função print(). vetor &lt;- 30:35 indices &lt;- seq_along(vetor) # cria o vetor de índices segundo o tamanho # do objeto vetor. for(i in indices) { print(vetor[1:i] / 2) } ## [1] 15 ## [1] 15.0 15.5 ## [1] 15.0 15.5 16.0 ## [1] 15.0 15.5 16.0 16.5 ## [1] 15.0 15.5 16.0 16.5 17.0 ## [1] 15.0 15.5 16.0 16.5 17.0 17.5 No trecho de código acima, preste atenção no resultado individual de cada uma das operações para entender como o R funciona. 3.5.3 while O código a seguir irá imprimir na tela o valor de i enquanto este objeto for menor que 3. No momento em que a condição dentro das chaves {} não for mais respeitada, o processo será interrompido. i &lt;- 1 while(i &lt; 3){ print(i) i = i + 1 } ## [1] 1 ## [1] 2 É importante que o valor de i seja atualizado em cada interação, caso contrário a função entrará em um loop infinito. Vamos usar o while para encontrar uma aproximação da solução de \\(\\sqrt{x} = x\\). Este método é conhecido como Interação do ponto fixo e pode ser usado no cálculo aproximado de soluções de equações de uma variável real. x &lt;- 4 erro &lt;- 100 while (abs(erro) &gt; 0.1) { erro &lt;- (sqrt(x)) - x x &lt;- sqrt(x) } print(x) ## [1] 1.090508 Quando a diferença entre \\(\\sqrt{x}\\) e \\(x\\) ficou menor que 0.1, o loop foi interrompido. Vemos que solução aproximada da equação \\(\\sqrt{x} = x\\) dada pelo algorítmo não difere muito da solução real \\(x=1\\). Para finalizar, listamos na tabela abaixo os principais operadores lógicos. Operador Descrição x &lt; y x menor que y? x &lt;= y x menor ou igual a y? x &gt; y x maior que y? x &gt;= y x maior ou igual a y? x == y x igual a y? x != y x diferente de y? !x Negativa de x x | y x ou y são verdadeiros? x &amp; y x e y são verdadeiros? xor(x, y) x ou y são verdadeiros (apenas um deles)? 3.6 Fórmulas Fórmulas são objetos do tipo y ~ x. Em geral, elas representam associações entre objetos, como em um modelo de regressão. As funções as usam de diversas maneiras, mas o exemplo mais emblemático vem da modelagem estatística. formula &lt;- y ~ x1 + x2 class(formula) ## [1] &quot;formula&quot; A função lm() é a que ajusta um modelo linear no R, e lm(y ~ x) lê-se “regressão linear de y explicada por x”. minha_formula &lt;- Sepal.Width ~ Petal.Length + Petal.Width class(minha_formula) ## [1] &quot;formula&quot; lm(minha_formula, data = iris) ## ## Call: ## lm(formula = minha_formula, data = iris) ## ## Coefficients: ## (Intercept) Petal.Length Petal.Width ## 3.5870 -0.2571 0.3640 No caso específico dos modelos lineares, são nas fórmulas que conseguimos descrever as variáveis explicativas e suas interações. A fórmula y ~ x1 * x2 significa “y regredido por x1, x2 e a interação entre x1 e x2”. Fórmulas aparecem frequentemente em tarefas de modelagem. Demais usos de fórmulas aparecerão em outras funções, como as do pacote ggplot2, com outros significados, e a documentação nos dirá como usá-las. 3.7 Gráficos (base) O R já vem com funções básicas que fazem gráficos estatísticos de todas as naturezas. Vantagens: são rápidas e simples. Desvantagens: são feias e difíceis para gerar gráficos complexos. Nesta seção, mostraremos como construir alguns tipos de gráficos usando as funções base do R, mas o nosso foco em visualização de dados está nas funções do pacote ggplot2. 3.7.1 Gráfico de dispersão Para construir um gráfico de dispersão, utilizamos a função plot(). Seus principais parâmetros são: x, y - Vetores para representarem os eixos x e y. type - Tipo de gráfico. Pode ser pontos, linhas, escada, entre outros. Para mais detalhes sobre os argumentos, ver help(plot). Outras formas de utilizar a função plot() Além de gerar gráficos de dispersão, tentar chamar a função plot(objeto_diferentao) para qualquer tipo de objeto do R geralmente gera um gráfico interessante! Sempre tente fazer isso, a menos que seu objeto seja um data.frame com milhares de colunas! N &lt;- 100 x &lt;- 1:N y &lt;- 5 + 2 * x + rnorm(N, sd = 30) plot(x, y) O parâmetro type = \"l\" indica que queremos que os pontos sejam interligados por linhas. plot(x, y, type = &quot;l&quot;) 3.7.2 Histograma Para construir histogramas, utilizamos a função hist(). Os principais parâmetros são: x - O vetor numérico para o qual o histograma será construído. breaks - O número (aproximado) de retângulos. hist(rnorm(1000)) hist(rnorm(1000), breaks = 6) 3.7.3 Boxplot Para construir histogramas, utilizamos a função boxplot(). Os principais parâmetros são: x - O vetor numérico para o qual o boxplot será construído. boxplot(InsectSprays$count, col = &quot;lightgray&quot;) Observe que o argumento col= muda a cor da caixa do boxplot. Para mapear duas variáveis ao gráfico, utilizamos um objeto da classe formula e o argumento data=. boxplot(count ~ spray, data = InsectSprays, col = &quot;lightgray&quot;) 3.7.4 Gráfico de barras Para construir gráficos de barras, precisamos combinar as funções table() e barplot(). No gráfico abaixo, primeiro criamos uma tabela de frequências com a função table() e, em seguida, construímos o gráfico com a função barplot(). A função data() carrega bases de dados de pacotes instalados. Veja help(data) para mais detalhes. data(diamonds, package = &quot;ggplot2&quot;) tabela &lt;- table(diamonds$color) tabela ## ## D E F G H I J ## 6775 9797 9542 11292 8304 5422 2808 barplot(tabela) Também podemos mapear duas variáveis a um gráfico de barras utilizando tabelas de dupla entrada. VADeaths ## Rural Male Rural Female Urban Male Urban Female ## 50-54 11.7 8.7 15.4 8.4 ## 55-59 18.1 11.7 24.3 13.6 ## 60-64 26.9 20.3 37.0 19.3 ## 65-69 41.0 30.9 54.6 35.1 ## 70-74 66.0 54.3 71.1 50.0 barplot(VADeaths) 3.8 Exercícios Sugestão: resolva os exercícios em arquivo R Markdown, aproveitando para fazer anotações e registrar suas dúvidas ao longo do caminho. 1. Calculo o número de ouro no R. Dica: o número de ouro é dado pela expressão \\(\\frac{1 + \\sqrt{5}}{2}\\). 2. Qual o resultado da divisão de 1 por 0 no R? E de -1 por 0? 3. Quais as diferenças entre NaN, NULL, NA e Inf? Digite expressões que retornam cada um desses resultados. 4. Sem rodar o código, calcule o que a expressão 5 + 3 * 10 %/% 3 == 15 vai resultar no R. Em seguida, apenas utilizando parênteses, faço a expressão retornar o valore contrário (i.e., se originariamente for TRUE, faça retornar FALSE). 5. Por que o código abaixo retorna erro? Arrume o código para retornar o valor TRUE. x &lt;- 4 if(x = 4) { TRUE } 6. Usando if e else, escreva um código que retorne a string “número” caso o valor seja da classe numeric ou integer; a string “palavra” caso o valor seja da classe character; e NULL caso contrário. 7. Use o for para retornar o valor mínimo do seguinte vetor: vetor &lt;- c(4, 2, 1, 5, 3). Modifique o seu código para receber vetores de qualquer tamanho. 8. Usando apenas for e a função length(), construa uma função que calcule a média de um vetor número qualquer. Construa uma condição para a função retornar NULL caso o vetor não seja numérico. 9. Rode help(runif) para descobrir o que a função runif() faz. Em seguida, use-a para escrever uma função que retorne um número aleatório inteiro entre 0 e 10 (0 e 10 inclusive). 10. Rode help(sample) para descobrir o que a função sample() faz. Em seguida, use-a para escrever uma função que escolha uma linha aleatoriamente de uma matriz e devolva os seus valores. 11. Rode help(paste) e help(names) para descobrir o que as funções paste() e names() fazem. Em seguida, use-as para escrever um código para gerar a fórmula mpg ~ cyl + disp + hp + drat + wt + qsec + vs + am + gear + carb a partir do data frame mtcars. 3.9 Respostas 1. Calculo o número de ouro no R. Dica: o número de ouro é dado pela expressão \\(\\frac{1 + \\sqrt{5}}{2}\\). Resposta: (1 + sqrt(5))/2 2. Qual o resultado da divisão de 1 por 0 no R? E de -1 por 0? Resposta: Infinito e -Infinito. 1/0 ## [1] Inf -1/0 ## [1] -Inf 3. Quais as diferenças entre NaN, NULL, NA e Inf? Digite expressões que retornam cada um desses resultados. Resposta: # NaN é o resultado de uma operação matemática inválida. # Significa Not A Number. 0/0 ## [1] NaN # NULL é o vazio do R. É como se o objeto não existisse. NULL a = NULL # veja que um vetor, mesmo sem elementos não é NULL is.null(integer(length = 0)) ## [1] FALSE # NA é uma constante lógica do R. Siginifica Not Availlable. # NA pode ser convertido para quase todos os tipos de vetores do R. # É usado principalmente para indicar valores faltantes. NA ## [1] NA as.numeric(c(&quot;1&quot;, &quot;2&quot;, &quot;a&quot;)) ## Warning: NAs introduced by coercion ## [1] 1 2 NA # Inf é significa infinito. É o resultado de operações matemáticas # cujo limite é infinito. 1/0 ## [1] Inf 1/Inf ## [1] 0 4. Sem rodar o código, calcule o que a expressão 5 + 3 * 10 %/% 3 == 15 vai resultar no R. Em seguida, apenas utilizando parênteses, faço a expressão retornar o valore contrário (i.e., se originariamente for TRUE, faça retornar FALSE). Resposta: O resultado da parte esquerda é 14, por isso a expressão retornará FALSE. Para fazê-la retornar TRUE, basta colocar parênteses em volta de 3 * 10. 5 + (3 * 10) %/% 3 == 15 ## [1] TRUE 5. Por que o código abaixo retorna erro? Arrume o código para retornar o valor TRUE. x &lt;- 4 if(x = 4) { TRUE } Resposta: A expressão x = 4 está tentando atribuir o valor 4 ao objeto x dentro do if, o que não é permitido pois o controlador if só aceita valores lógicos. Para corrigir o código e fazê-lo retornar TRUE, basta trocar = por ==. x &lt;- 4 if(x == 4) { TRUE } ## [1] TRUE 6. Usando if e else, escreva um código que retorne a string “número” caso o objeto x seja da classe numeric ou integer; a string “palavra” caso o objeto seja da classe character; e NULL caso contrário. Resposta: x &lt;- 1 # x &lt;- 1L # x &lt;- &quot;1&quot; if(is.numeric(x)) { &quot;número&quot; } else if(is.character(x)) { &quot;palavra&quot; } else { NULL } ## [1] &quot;número&quot; Note que a função is.numeric() retorna TRUE para as classes integer e numeric. 7. Use o for para retornar o valor mínimo do seguinte vetor: vetor &lt;- c(4, 2, 1, 5, 3). Modifique o seu código para receber vetores de qualquer tamanho. Resposta: vetor &lt;- c(4, 2, 1, 5, 3) minimo &lt;- Inf for(i in 1:5) { if(minimo &gt; vetor[i]) { minimo &lt;- vetor[i] } } minimo ## [1] 1 Lembrete: o R já possui a função min() para calcular o mínimo de um conjunto de valores. 8. Usando apenas for e a função length(), construa uma função que calcule a média de um vetor número qualquer. Construa uma condição para a função retornar NULL caso o vetor não seja numérico. Resposta: media &lt;- function(x) { i &lt;- 1 tamanho &lt;- length(x) soma &lt;- 0 for(i in 1:tamanho){ soma &lt;- soma + x[i] } return(soma/tamanho) } media(1:3) ## [1] 2 9. Rode help(runif) para descobrir o que a função runif() faz. Em seguida, use-a para escrever uma função que retorne um número aleatório inteiro entre 0 e 10 (0 e 10 inclusive). Resposta: A função runif() gera números reais aleatórios entre um valor mínimo e um valor máximo. alea &lt;- function() { x &lt;- runif(n = 1, min = 0, max = 10) x &lt;- round(x) return(x) } alea() ## [1] 5 Veja que construímos uma função sem argumentos. Podemos generalizá-la incluindo os argumentos da função runif(). alea &lt;- function(n, min, max) { x &lt;- runif(n = n, min = min, max = max) x &lt;- round(x) return(x) } alea(2, 2, 5) ## [1] 4 5 alea(5, 100, 105) ## [1] 104 102 101 101 102 Observe que não há problema em usar os mesmos nomes para os argumentos. Isso se deve aos environments. 10. Rode help(sample) para descobrir o que a função sample() faz. Em seguida, use-a para escrever uma função que escolha uma linha aleatoriamente de uma matriz e devolva os seus valores. Resposta: matriz &lt;- matrix(runif(20), nrow = 5, ncol = 4) linha_alea &lt;- function(matriz) { x &lt;- 1:nrow(matriz) linha &lt;- sample(x, size = 1) return(matriz[linha,]) } matriz ## [,1] [,2] [,3] [,4] ## [1,] 0.9476913 0.37040185 0.3422454 0.96524849 ## [2,] 0.6450708 0.68039543 0.1569188 0.54769243 ## [3,] 0.8296116 0.98706017 0.8532506 0.55424712 ## [4,] 0.4860344 0.66333462 0.3593599 0.28477291 ## [5,] 0.1338947 0.04237775 0.8893972 0.05976397 linha_alea(matriz) ## [1] 0.9476913 0.3704018 0.3422454 0.9652485 11. Rode help(paste) e help(names) para descobrir o que as funções paste() e names() fazem. Em seguida, use-as para escrever um código para gerar a fórmula mpg ~ cyl + disp + hp + drat + wt + qsec + vs + am + gear + carb a partir do data frame mtcars. Resposta: variaveis &lt;- names(mtcars) esq &lt;- &quot;mpg ~ &quot; dir &lt;- paste(variaveis[-1], collapse = &quot; + &quot;) formula &lt;- paste0(esq, dir) as.formula(formula) ## mpg ~ cyl + disp + hp + drat + wt + qsec + vs + am + gear + carb Observe que a função paste0() é equivalente à função paste() com o argumento sep = \"\". Essa ideia é um dos princípios por trás do tidyverse.↩ Você pode construir um data frame vazio, com 0 linha e 0 coluna. No entanto, a estrutura de linhas e colunas estará presente.↩ A primeira “coluna” representa apenas o nome das linhas (modelo do carro), não é uma coluna da base. Repare que ela não possui um nome, como as outras. Essa estrutura de nome de linha é própria de data frames no R. Se exportássemos essa base para o Excel, por exemplo, essa coluna não apareceria.↩ "]
]
