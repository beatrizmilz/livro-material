
```{r, include=FALSE}
knitr::opts_chunk$set(
  fig.align = "center",
  cache = TRUE
)
```

# Visualização {#graficos}

Agora que já temos em mãos as ferramentas para importar, arrumar, transformar e sumarizar os nossos dados, podemos dar um passo adiante no ciclo da Ciência de Dados: a construção de *visualizações*.

Visualizar os dados é uma etapa importantíssima da análise estatística, pois é a partir dela que criamos boa parte da intuição necessária para escolher o teste ou modelo mais adequado para o nosso problema. Muitas vezes, um problema de análise de dados pode ser resolvido apenas com visualizações. Além disso, elas são o principal combustível da etapa de Comunicação da análise.

Visualizações podem ser uma simples medida resumo (frequência, média, variância, mínimo, máximo etc), um conjunto dessas medidas organizadas em uma tabela ou a representação (de uma parte) dos dados em um gráfico. Neste capítulo, mostraremos como construir gráficos e tabelas bem formatadas dentro do R. Começaremos com a construção de gráficos e, em seguida, falaremos sobre a formatação de tabelas^[Em geral, boa parte do trabalho necessário para a construção de uma tabela descritiva pode ser feito com as funções dos pacotes `{dplyr}` e `{tidyr}`, vistas no capítulo anterior.].

Mas, antes de mais nada, o que é um gráfico estatístico?

## O pacote ggplot2

A construção de gráficos no R foi revolucionada com a criação do pacote `ggplot2`, fruto da tese de doutorado do [Hadley Wickham](https://github.com/hadley). Essa revolução teve base na filosofia que Hadley adotou para responder a pergunta "O que é um gráfico estatístico?".

Em 2005, o estatístico norte-americano Leland Wilkinson publicou o livro [*The Grammar of graphics*](http://www.springer.com/statistics/computational+statistics/book/978-0-387-24544-7) (*A gramática dos gráficos*, em português), uma fonte de princípios fundamentais para a construção de gráficos estatísticos. No livro, ele defende que um gráfico é o mapeamento dos dados em atributos estéticos (posição, cor, forma, tamanho) de formas geométricas (pontos, linhas, barras, caixas).

A partir dessa definição, Hadley escreveu [A Layered Grammar of Graphics](http://vita.had.co.nz/papers/layered-grammar.html) (*Uma gramática em camada dos gráficos*), acrescentando que os elementos de um gráfico (dados, sistema de coordenadas, rótulos, anotações, entre outros) são as suas camadas e que a construção de um gráfico se dá pela sobreposição dessas camadas.

Essa é a essência do `ggplot2`: construir um gráfico camada por camada.

Além de uma filosofia bem fundamentada, o `ggplot2` ainda traz outras vantagens em relação aos gráficos do R base:

- gráficos naturalmente mais bonitos;
- fácil personalização (mais simples deixar o gráfico do jeito que você quer);
- a estrutura padronizada das funções deixa o aprendizado muito mais intuitivo;
- a diferença no código entre tipos diferentes de gráficos é muito pequena.

Para discutir os principais aspectos da construção de gráficos com o `ggplot2`, vamos continuar utilizando a base de filmes do IMDB. Você pode baixá-la [clicando aqui](https://github.com/curso-r/livro-material/raw/master/assets/data/imdb.rds).

Na próxima seção, vamos conhecer as principais funções do `ggplot2` e começar a construir nossos primeiros gráficos. Não se esqueça de instalar e carregar o pacote antes de rodar os exemplos.

```{r, eval=FALSE}
install.packages("ggplot2")
library(ggplot2)
```

```{r, echo=FALSE}
library(ggplot2)
```

### Gráficos de pontos (dispersão)

No `ggplot2`, os gráficos são construídos camada por camada, sendo a primeira delas dada pela função `ggplot()` (repare que não tem o "2"). Essa função recebe um *data frame* e cria a camada base do gráfico, o nosso *canvas*, onde acrescentaremos todos os outros elementos (camadas). 

Se rodarmos apenas a função `ggplot()`, obteremos um painel em branco.

```{r}
imdb <- readr::read_rds("assets/data/imdb.rds")
ggplot(data = imdb)
```

Apesar de termos passado os dados para a função, precisamos especificar como as observações serão mapeadas nos aspectos visuais do gráfico e quais formas geométricas serão utilizadas para isso.

O código abaixo constrói um gráfico de dispersão entre as variáveis orçamento e receita.

```{r}
ggplot(imdb) +
  geom_point(mapping = aes(x = orcamento, y = receita))
```

Observe que:

- a primeira camada é dada pela função `ggplot()` e recebe a nossa base `imdb`;
- a segunda camada é dada pela função `geom_point()`, especificando a forma **geom**étrica utilizada no mapeamento das observações (pontos);
- as camadas são unidas com um `+`;
- o mapeamento na função `geom_point()` recebe a função `aes()`, responsável por descrever como as variáveis serão mapeadas nos aspectos visuais dos pontos (a forma geométrica escolhida);
- neste caso, os aspectos visuais mapeados são a posição do ponto no eixo x e a posição do ponto no eixo y;
- o `Warning` nos avisa sobre a exclusão das observações que possuem `NA` na variável receita e/ou orçamento;
- todas essas funções são do pacote `{ggplot2}`.

A combinação da função `ggplot()` e de uma ou mais funções `geom_()` definirá o tipo de gráfico gerado. 

O primeiro argumento de qualquer função `geom` é o `mapping`. Esse argumento serve para mapear os dados nos atributos estéticos da forma geométrica escolhida. Ele sempre receberá a função `aes()`, cujos argumentos vão sempre depender da forma geométrica que estamos utilizando. No caso de um gráfico de dispersão, precisamos definir a posição dos pontos nos eixos x e y. No exemplo, a posição do ponto no eixo x foi dada pela coluna `orcamento` e a posição do ponto no eixo y pela coluna `receita`.

> **Atenção!** As camadas dos gráficos são empilhadas utilizando-se o sinal `+`. Como a estrutura é muito parecida com a do *pipe*, é comum trocarmos o `+` por um `%>%` no meio do código, resultando em erro.

Podemos acrescentar uma terceira camada ao gráfico, desenhando a reta `y = x` para visualizarmos os filmes não se pagaram.

```{r}
ggplot(imdb) +
  geom_point(mapping = aes(x = orcamento, y = receita)) +
  geom_abline(intercept = 0, slope = 1, color = "red")
```

Os pontos abaixo da reta representam os filmes com orçamento maior que a receita, isto é, aqueles que deram prejuízo.  

A reta x = y foi acrescentada ao gráfico pela função `geom_abline()`. Esse `geom` pode ser utilizado para desenhar qualquer reta do tipo `y = a + b * x`, sendo `a` o intercepto (*intercept*) da reta e `b` o seu coeficiente angular (*slope*).

Neste caso, como não estamos mapeando colunas da base a essa reta (isto é, essa reta não depende dos dados), não precisamos utilizar o argumento `mapping` da função `geom_abline()`, tampouco a função `aes()`.

Para ver como um ggplot realmente é construído por camadas, veja o que acontece quando colocamos a camada da reta antes da camada dos pontos:

```{r}
ggplot(imdb) +
  geom_abline(intercept = 0, slope = 1, color = "red")
  geom_point(mapping = aes(x = orcamento, y = receita)) 
```

Além da posição nos eixos x e y, podemos mapear a cor dos pontos a uma variável.

```{r}
library(dplyr)

imdb %>%
  mutate(lucro = receita - orcamento) %>% 
  ggplot() +
  geom_point(aes(x = orcamento, y = receita, color = lucro))
```

O gráfico acima tem a cor dos pontos definida pelo valor da variável lucro. Como a coluna `lucro` é numérica, um degradê é criado para a cor dos pontos. O azul é a cor padrão nesses casos (veremos mais adiante como escolher a cor).

Veja que criamos a coluna `lucro` utilizando a função `mutate()` antes de iniciarmos a construção do gráfico. O fluxo `base %>% manipulação %>% ggplot` é muito comum no dia-a-dia.

> Por trás de um grande gráfico sempre existe uma grande tabela.

Poderíamos também classificar os filmes entre aqueles que lucraram ou não. Neste caso, como a coluna `lucrou` é textual, uma cor é atribuída a cada categoria.

```{r gglucro}
imdb %>%
   mutate(
    lucro = receita - orcamento,
    lucro = ifelse(lucro <= 0, "Não", "Sim")
  ) %>% 
  filter(!is.na(lucro)) %>% 
  ggplot() + 
  geom_point(mapping = aes(x = orcamento, y = receita, color = lucro))
```

Um erro comum na hora de definir atributos estéticos de um gráfico é definir valores para atributos estéticos dentro da função `aes()`. Repare o que acontece quando tentamos definir diretamente a cor dos pontos dentro dessa função.

```{r}
ggplot(imdb) +
  geom_point(aes(x = orcamento, y = receita, color = "blue"))
```

Estranho, não? O que aconteceu foi o seguinte: a função `aes()` espera uma coluna para ser mapeada a cada atributo, então o valor `blue` é tratado como uma nova variável/coluna que tem essa string para todas as observações. Assim, todos pontos têm a mesma cor (vermelha, padrão do ggplot) pois pertencem todos à essa "categoria *blue*".

No caso, o que gostaríamos é de ter pintado todos os pontos de azul. A forma certa de fazer isso é colocando o atributo `color=` fora da função `aes()`: 

```{r}
ggplot(imdb) +
  geom_point(aes(x = orcamento, y = receita), color = "blue")
```

### Gráficos de linhas




------------------------



### Formas geométricas

Os *geoms* definem qual forma geométrica será utilizada para a visualização das observações. Como já vimos, a função `geom_point()` gera gráficos de dispersão
transformando pares $(x,y)$ em pontos. Veja a seguir outros *geoms* bastante utilizados:

- `geom_line` - para linhas definidas por pares (x,y).
- `geom_abline` - para retas definidas por um intercepto e uma inclinação.
- `geom_hline` - para retas horizontais.
- `geom_bar` - para barras.
- `geom_histogram` - para histogramas.
- `geom_boxplot` - para boxplots.
- `geom_density` - para densidades.
- `geom_area` - para áreas.

Veja a seguir como é fácil gerar diversos gráficos diferentes utilizando a mesma estrutura do gráfico de dispersão acima:

#### Linhas

```{r}
imdb %>% 
  filter(diretor == "Steven Spielberg") %>%
  group_by(ano) %>% 
  summarise(nota_media = mean(nota_imdb, na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x = ano, y = nota_media))
```


#### Histograma

```{r}
ggplot(imdb) + 
  geom_histogram(aes(x = orcamento), color = "black", fill = "white")
```

Enquanto o gráfico e dispersão demandam o mapeamento das posições x e y, o histograma requer apenas a posição x, já que, pela definição do gráfico, o eixo mostra a frequência de cada classe.

#### Boxplot

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita))
```

Repare que o boxplot pede uma variável categórica no eixo x.

#### Gráfico de barras

Há duas formas de fazer um gráfico de barras. A primeira é utilizando a função `geom_bar()`, quando queremos que a função conte a frequência de cada categoria.

```{r}
imdb %>% 
  filter(ano > 1990) %>% 
  ggplot() +
  geom_bar(aes(x = ano), color = "black", fill = "light blue")
```

Ou a função `geom_col()`, quando já temos essas contagens.

```{r}
imdb %>% 
  count(diretor) %>% 
  filter(!is.na(diretor)) %>% 
  dplyr::top_n(5, n) %>%
  ggplot() +
  geom_bar(
    aes(x = diretor, y = n), 
    stat = "identity", 
    color = "red", 
    fill = "pink"
  )
```


### Juntando gráficos

No ggplot, temos várias formas de juntar gráficos. Vamos apresentar a seguir as principais.

#### Vários geoms no mesmo gráfico

Podemos acrescentar vários geoms em um mesmo gráfico, apenas adicionando novas camadas. No código abaixo, construímos o gráfico de dispersão da receita pelo orçamento dos filmes, acrescentando também uma reta de tendência aos pontos.

```{r}
ggplot(imdb) +
  geom_point(aes(x = orcamento, y = receita)) +
  geom_smooth(aes(x = orcamento, y = receita), se = FALSE, method = "lm")
```

Quando estamos usando mais de um geom, podemos economizar código especificando o `aes()` diretamente na função `ggplot()`. O mapeamento então é distribuído para todos os geoms do gráfico.

```{r}
ggplot(imdb, aes(x = orcamento, y = receita)) +
  geom_point() +
  geom_smooth(se = FALSE, method = "lm")
```

Mas você ainda pode usar o `aes()` dentro dos geoms para especificar mapeamentos específicos.

```{r}
ggplot(imdb, aes(x = orcamento, y = receita)) +
  geom_point(aes(color = ano)) +
  geom_smooth(color = "black", se = FALSE, method = "lm")
```


#### Replicando um gráfico para cada categoria de uma variável

Uma funcionalidade muito útil do `ggplot2` é a possibilidade de usar `facets` para replicar um gráfico para cada categoria de uma variável.

```{r}
imdb %>%
  filter(classificacao %in% c("Livre", "A partir de 13 anos")) %>%
  ggplot() +
  geom_point(aes(x = orcamento, y = nota_imdb)) +
  facet_wrap(~classificacao, nrow = 2)
```

Repare que usamos uma fórmula para dizer à função qual variável vamos utilizar para quebrar o gráfico. Podemos especificar se queremos os gráficos lado a lado ou um embaixo do outro pelos argumentos `nrow=` e `ncol=`.

```{r}
imdb %>%
  filter(classificacao %in% c("Livre", "A partir de 13 anos")) %>%
  ggplot() +
  geom_point(aes(x = orcamento, y = nota_imdb)) +
  facet_wrap(~classificacao, ncol = 2)
```

**Exercício relâmpago!** Pesquise o que faz a função `facet_grid()`.

#### Juntando gráficos diferentes

Diversos outros pacotes trazem ferramentas super úteis para trabalharmos com o `ggplot2`. Um deles é o pacote `patchwork`. Após carregá-lo, podemos juntar dois gráficos com um simples `+`.

```{r}
# Instale antes de carregar
# devtools::install_github("thomasp85/patchwork")

library(patchwork)

p1 <- imdb %>% 
  filter(diretor == "Steven Spielberg") %>%
  group_by(ano) %>% 
  summarise(nota_media = mean(nota_imdb, na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x = ano, y = nota_media))

p2 <- imdb %>% 
  mutate(lucro = receita - orcamento) %>% 
  filter(diretor == "Steven Spielberg") %>% 
  ggplot() +
  geom_histogram(
    aes(x = lucro),
    fill = "lightblue", 
    color = "darkblue", 
    binwidth = 100000000
  )

p1 + p2
```


### Personalizando

Como exemplo de personalização de um gráfico com o `ggplot2`, vamos partir de um simples boxplot e fazer diversas alterações no seu visual. 

O gráfico inicial é construído da seguinte forma:

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor))
```

#### Removendo totalmente a legenda

Existem diversas maneiras para remover a legenda de um gráfico no `ggplot2`. A forma mais simples é usar o argumento `show.legend = FALSE` dentro do geom.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE)
```

#### Mexendo na escala

Para mudar qualquer aspecto estético da escala, usamos a família de funções `scale_()`. No caso, vamos deixar a escala do eixo y no formato de dólares.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) +
  scale_y_continuous(labels = scales::dollar)
```

Repare que para cada tipo de atributo, existe uma função `scale_()` correspondente.

#### Alterando a ordem das categorias

Para alterar a ordem que as categorias de uma variável aparecem no gráfico, podemos utilizar o argumento `breaks=` da função `scale_()`.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  )
```

Também é possível fazer isso usando as funções do pacote `forcats`, apresentado com detalhes [aqui](https://www.curso-r.com/material/forcats/).

#### Escolhendo cores manualmente

O pacote`ggplot2` utiliza uma palheta de cores padrão. Se você quiser especificar as suas próprias cores, faça isso utilizando a função `scale_()`.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  ) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9"))
```

#### Modificando o visual do gráfico

Podemos mudar aspectos visuais do gráfico, como fontes, cores e estilos dos textos, grids, marcações, cor do fundo etc, a partir da função `theme()`. No exemplo abaixo, eliminamos o texto e as marcações do eixo $x$.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor)) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  ) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9")) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

#### Modificando a posição da legenda

É possível controlar a posição da legenda facilmente escolhendo uma das posições:  `left`, `right`, `top` e `bottom`.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor)) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  ) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9")) +
  theme(
    axis.text.x = element_blank(), 
    axis.ticks.x = element_blank(),
    legend.position = "bottom"
  )
```

Existem alguns temas já prontos disponíveis no `ggplot2`. Veja alguns exemplos.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  ) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9")) +
  theme_bw()

imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  ) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9")) +
  theme_minimal()

imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  ) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9")) +
  theme_dark()
```

#### Acrescentando título

Para acrescentar um título ao seu gráfico, utilize a função `ggtitle()`.

```{r}
imdb %>% 
  filter(diretor %in% c("Steven Spielberg", "Quentin Tarantino", "Woody Allen")) %>%
  ggplot() + 
  geom_boxplot(aes(x = diretor, y = receita, fill = diretor), show.legend = FALSE) +
  scale_y_continuous(labels = scales::dollar) +
  scale_x_discrete(
    limits = c("Woody Allen", "Quentin Tarantino", "Steven Spielberg")
  ) +
  scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9")) +
  theme_minimal() +
  ggtitle("Meu boxplot bonitão")
```

### Onde continuar estudando?

O pacote `ggplot2` tem incontáveis funcionalidades, principalmente na hora de personalizar o seu gráfico. Abordamos aqui apenas algumas poucas delas. Para continuar aprendendo, sugerimos as seguintes referências:

- O [capítulo de visualizações do R4DS](https://r4ds.had.co.nz/data-visualisation.html) é um ótimo material para fixar os conceitos básicos.

- O [capítulo de gráficos do livro R Cookbook](http://www.cookbook-r.com/Graphs/) é um bom material de consulta para relembrar velhos truques e descobrir novas formas de personalizar seu gráfico.

- O site [ggplot2 extensions](https://exts.ggplot2.tidyverse.org/) tem uma galeria com diversos pacotes que deixam o ggplot2 bem mais poderoso, indo de novos geoms até animações.

```{r}
library(ggridges)

imdb %>%
  filter(ano > 2005) %>% 
  mutate(ano = as.factor(ano)) %>% 
  ggplot(aes(y = ano, x = receita, fill = ano)) +
  geom_density_ridges(na.rm = TRUE, show.legend = FALSE)
```


### Exercícios

**1.** O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
```

**2.** Mapeie uma variável contínua para uma cor, tamanho e forma. Como essas formas
estéticas se comportam diferente para variáveis categóricas vs contínuas?

**3.** O que acontece se você rodar `ggplot(data = mtcars)`?


**4.** Utilizando o `mtcars`, faça um gráfico de dispersão de `mpg` por `qsec`.

**5.** Utilizando o `mtcars`, o que acontece se você fizer um gráfico de dispersão de `vs` por `mpg`? Por que o gráfico não é útil?
